import asyncio
import json
import logging
import os
from collections import defaultdict
from typing import Dict, Any

import aiofiles
from aiogram import Bot, Dispatcher, types, Router
from aiogram.enums import ChatMemberStatus
from aiogram.filters import CommandStart
from aiogram.types import FSInputFile, InlineKeyboardMarkup, InlineKeyboardButton

import config
from color_data import color_dict, evaluation_criteria, color_to_system, evaluation_icons

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–∞, ID –∫–∞–Ω–∞–ª–∞ –∏ —Ñ–∞–π–ª–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
API_TOKEN: str = config.API_TOKEN
CHANNEL_ID: int = config.CHANNEL_ID
DATA_FILE: str = config.DATA_FILE

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞, –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞ –∏ —Ä–æ—É—Ç–µ—Ä–∞
bot: Bot = Bot(token=API_TOKEN)
dp: Dispatcher = Dispatcher()
router: Router = Router()

# –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–π —Å —Ñ–∞–π–ª–æ–º –¥–∞–Ω–Ω—ã—Ö
data_lock = asyncio.Lock()

# –•—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: –±–∞–ª–ª—ã –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å —Ç–µ—Å—Ç–∞
user_scores: Dict[int, Dict[str, int]] = defaultdict(lambda: {color: 0 for color in list(color_dict.values())[0]})
user_progress: Dict[int, int] = defaultdict(int)

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(message)s")
# ==============================
# –§—É–Ω–∫—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏
# ==============================
async def load_user_data() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        async with aiofiles.open(DATA_FILE, 'r', encoding='utf-8') as f:
            try:
                data = json.loads(await f.read())
                return data or {'scores': {}, 'progress': {}}
            except json.JSONDecodeError:
                logging.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ñ–∞–π–ª–∞ JSON.")
    return {'scores': {}, 'progress': {}}

async def save_user_data() -> None:
    async with data_lock, aiofiles.open(DATA_FILE, 'w', encoding='utf-8') as f:
        data = {
            'scores': dict(user_scores),
            'progress': dict(user_progress)
        }
        await f.write(json.dumps(data, ensure_ascii=False, indent=4))

async def init_user_data() -> None:
    global user_scores, user_progress
    data = await load_user_data()
    user_scores.update(data.get('scores', {}))
    user_progress.update(data.get('progress', {}))
# ==============================
# –§—É–Ω–∫—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —Å –ø–æ–¥–ø–∏—Å–∫–æ–π
# ==============================
async def is_user_subscribed(user_id: int) -> bool:
    try:
        status = (await bot.get_chat_member(CHANNEL_ID, user_id)).status
        return status in {ChatMemberStatus.MEMBER, ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.CREATOR}
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
    return False
# ==============================
# –§—É–Ω–∫—Ü–∏–∏ —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä
# ==============================
def create_buttons(buttons: list[tuple[str, str]]) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text=text, callback_data=callback)] for text, callback in buttons]
    )

def get_answer_buttons(qid: int) -> InlineKeyboardMarkup:
    return create_buttons([
        ("‚úÖ –¢–∞–∫", f"yes_{qid}"),
        ("‚ùå –ù—ñ", f"no_{qid}"),
        ("‚è≠ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏", f"skip_{qid}")
    ])

def get_subscribe_button() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üîî –ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è", url="https://t.me/tteessttooss")],
            [InlineKeyboardButton(text="‚úÖ –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—ñ–¥–ø–∏—Å–∫—É", callback_data="check_subscription")]
        ]
    )

def get_start_buttons() -> InlineKeyboardMarkup:
    return create_buttons([
        ("‚úÖ –¢–∞–∫", "start_test"),
        ("‚ùå –ù—ñ", "cancel_start")
    ])

def get_restart_buttons() -> InlineKeyboardMarkup:
    return create_buttons([
        ("üîÑ –¢–∞–∫, –ø–æ—á–∞—Ç–∏ –∑–∞–Ω–æ–≤–æ", "restart_test"),
        ("‚ùå –ù—ñ", "cancel_restart")
    ])

def get_main_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="‚öôÔ∏è –û–ø—Ü—ñ—è 1 (–≤ —Ä–æ–∑—Ä–æ–±—Ü—ñ)", callback_data="dev_1"),
                InlineKeyboardButton(text="üîß –û–ø—Ü—ñ—è 2 (–≤ —Ä–æ–∑—Ä–æ–±—Ü—ñ)", callback_data="dev_2")
            ],
            [
                InlineKeyboardButton(text="üìú –û–ø—Ü—ñ—è 3 (–≤ —Ä–æ–∑—Ä–æ–±—Ü—ñ)", callback_data="dev_3"),
                InlineKeyboardButton(text="üéØ –û–ø—Ü—ñ—è 4 (–≤ —Ä–æ–∑—Ä–æ–±—Ü—ñ)", callback_data="dev_4")
            ],
            [
                InlineKeyboardButton(text="üìù –ü—Ä–æ–π—Ç–∏ —Ç–µ—Å—Ç", callback_data="start_test")
            ]
        ]
    )
# ==============================
# –§—É–Ω–∫—Ü–∏–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
# ==============================
@router.message(CommandStart())
async def send_welcome(message: types.Message) -> None:
    photo = FSInputFile("img/1.png")
    await message.answer_photo(
        photo=photo,
        caption="üëã –õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ! –í–∏–±–µ—Ä—ñ—Ç—å –¥—ñ—é:",
        reply_markup=get_main_menu()
    )
last_message_was_question: defaultdict[int, bool] = defaultdict(bool)

async def send_next_question(user_id: int, message: types.Message) -> None:
    qid = user_progress[user_id]
    if qid >= len(color_dict):
        await send_results(user_id, message)
        last_message_was_question[user_id] = False
        return
    question_text = f"–ü–∏—Ç–∞–Ω–Ω—è {qid + 1}: {list(color_dict.keys())[qid]}"
    buttons = get_answer_buttons(qid)
    try:
        if last_message_was_question[user_id]:
            await message.edit_text(question_text, reply_markup=buttons)
        else:
            await message.answer(question_text, reply_markup=buttons)
    except Exception as e:
        logging.error(f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤—ñ–¥–ø—Ä–∞–≤—Ü—ñ/—Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—ñ –ø–∏—Ç–∞–Ω–Ω—è: {e}")
        await message.answer(question_text, reply_markup=buttons)
    last_message_was_question[user_id] = True


async def reset_and_start_test(user_id: int, message: types.Message) -> None:
    user_scores[user_id] = {color: 0 for color in list(color_dict.values())[0]}
    user_progress[user_id] = 0
    await save_user_data()
    await message.answer("–ë—É–¥—å —á–µ—Å–Ω–∏–º–∏ —ñ–∑ —Å–æ–±–æ—é, –∫–æ–ª–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î—Ç–µ.")
    await send_next_question(user_id, message)


@router.callback_query(lambda c: c.data == "start_test")
async def start_test(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    if user_progress[user_id] > 0:
        await callback.message.answer(
            "üîÑ –í–∏ –≤–∂–µ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ —Ç–µ—Å—Ç. –•–æ—á–µ—Ç–µ –ø–æ—á–∞—Ç–∏ –∑–∞–Ω–æ–≤–æ?",
            reply_markup=get_restart_buttons()
        )
        return
    await reset_and_start_test(user_id, callback.message)

@router.callback_query(lambda c: c.data == "restart_test")
async def restart_test(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    await reset_and_start_test(user_id, callback.message)

@router.callback_query(lambda c: c.data.startswith(('yes_', 'no_', 'skip_')))
async def handle_answer(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    try:
        qid = int(callback.data.split('_')[1])
    except (IndexError, ValueError):
        logging.error("–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç callback data.")
        return
    if callback.data.startswith("yes_"):
        # –ü—Ä–∏ –æ—Ç–≤–µ—Ç–µ "—Ç–∞–∫" —Å—É–º–º–∏—Ä—É–µ–º –±–∞–ª–ª—ã –ø–æ –∫–∞–∂–¥–æ–º—É —Ü–≤–µ—Ç—É
        for color, value in color_dict[list(color_dict.keys())[qid]].items():
            user_scores[user_id][color] += value
    user_progress[user_id] += 1
    await save_user_data()
    await send_next_question(user_id, callback.message)

@router.callback_query(lambda c: c.data == "check_subscription")
async def check_subscription_callback(callback: types.CallbackQuery) -> None:
    user_id = callback.from_user.id
    if await is_user_subscribed(user_id):
        await callback.message.answer("‚úÖ –í–∏ –ø—ñ–¥–ø–∏—Å–∞–Ω—ñ! –û—Å—å –≤–∞—à—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏:")
        await send_results(user_id, callback.message)
    else:
        await callback.message.edit_text(
            "‚ùå –ü—ñ–¥–ø–∏—à—ñ—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª:",
            reply_markup=get_subscribe_button()
        )

async def check_subscription(user_id: int, message: types.Message) -> None:
    if await is_user_subscribed(user_id):
        await send_results(user_id, message)
    else:
        await message.edit_text(
            "‚ùå –©–æ–± –ø–æ–±–∞—á–∏—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏, –ø—ñ–¥–ø–∏—à—ñ—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª:",
            reply_markup=get_subscribe_button()
        )

async def send_results(user_id: int, message: types.Message) -> None:
    scores = user_scores.get(user_id, {})
    if not scores:
        await message.answer("‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞! –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏.")
        return
    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ —É–±—ã–≤–∞–Ω–∏—é –±–∞–ª–ª–æ–≤
    sorted_scores = sorted(scores.items(), key=lambda x: x[1], reverse=True)
    result_lines = []
    for color, score in sorted_scores:
        evaluation = evaluate_color_score(color, score)
        icon = evaluation_icons.get(evaluation, '‚ö™')
        system = color_to_system.get(color, '–ù–µ–≤—ñ–¥–æ–º–∞ —Å–∏—Å—Ç–µ–º–∞')
        result_lines.append(f"{icon} *{system}:* {evaluation}")
    result_text = "‚¨áÔ∏è *–í–∞—à—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏:*\n" + "\n".join(result_lines)
    try:
        photo = FSInputFile("img/1.png")
        await bot.send_photo(
            chat_id=user_id,
            photo=photo,
            caption=result_text,
            parse_mode="Markdown"
        )
        await message.edit_text("‚úÖ –í–∞—à—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ!", reply_markup=None)
    except Exception as e:
        logging.error(f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤—ñ–¥–ø—Ä–∞–≤—Ü—ñ —Ñ–æ—Ç–æ –∞–±–æ —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {e}")
        await message.answer(result_text.strip(), parse_mode="Markdown")

def evaluate_color_score(color: str, score: int) -> str:
    return next(
        (eval_str for threshold, eval_str in evaluation_criteria[color] if score <= threshold),
        "–ù–µ–≤—ñ–¥–æ–º–æ"
    )
# ==============================
# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞
# ==============================
async def main() -> None:

    await init_user_data()
    dp.include_router(router)
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
